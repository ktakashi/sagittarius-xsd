#!/bin/env sash
;; -*- mode:scheme; coding:utf-8; -*-
#!read-macro=sagittarius/regex
(import (rnrs)
	(clos core)
	(clos user)
	(sagittarius object)
	(sagittarius regex)
	(sagittarius control)
	(text sxml xsd schema)
	(getopt)
	(srfi :1)
	(srfi :13)
	(srfi :26)
	(srfi :39)
	(text sxml tools)
	(pp))

(define (usage)
  (print "Usage: xsd2scm [OPTION...] FILE")
  (print "Options:")
  (print "  -l<library-name>,--library=<library-name>")
  (print "   Generates Scheme class in R6RS library form named <library-name>.")
  (print)
  (print "  -I<dir>,--include=<dir>")
  (print "   Specifies include directory. If the target FILE contains include")
  (print "   or import then <dir> will be one of the candidate directory.")
  (print "   This option can be passed multiple times.")
  (print)
  (print "  -o<file>,--output=<file>")
  (print "   Specifies output file. By default stdout.")
  (exit 0))

(define (fixup-locator includes)
  (lambda (schema-location)
    (let ((file (exists (lambda (include)
			  (let ((p (build-path include schema-location)))
			    (and (file-exists? p) p))) includes)))
      (if file
	  (file-locator file)
	  (error 'xsd2scm "import/included XSD does not exist on tha path"
		 schema-location includes)))))

;; naive
(define (->scheme-name name)
  (let ((name (regex-replace-first #/^([A-Z]+)/ name
	        (lambda (m) (string-downcase (m 1))))))
    (regex-replace-all #/([A-Z]+)/ name
      (lambda (m) (string-append "-" (string-downcase (m 1)))))))

(define (->scheme-class-name name :optional (with-type? #t))
  (let ((name (->scheme-name name)))
    (string-append "<" name (if with-type? "-type" "") ">")))

(define (->keyword s) (make-keyword (string->symbol s)))

(define (->scheme-type type)
  (let ((ncname (sxml:ncname (list (string->symbol type)))))
    (if (or (string-prefix? +xsd-2001-ns-uri+ type)
	    (string-prefix? +xsd-2000-ns-uri+ type)
	    (string-prefix? +xsd-1999-ns-uri+ type))
	(->keyword ncname)
	(string->symbol (->scheme-class-name ncname)))))

(define (class->slot-name class)
  (let ((name (symbol->string class)))
    (string->symbol (cond ((#/^<(.+?)>$/ name) => (lambda (m) (m 1)))
			  (else (error 'class->slot-name 
				       "[internal] bad name" class))))))


(define *parents* (make-parameter '()))

;; for xs:extension
;; key:   full-name
;; value: <complex-type>
(define type-table (make-string-hashtable))

(define-class <type> ()
  ((name :init-keyword :name)
   (element :init-keyword :element)
   (full-name :init-keyword :full-name)
   ;; for annonymous
   (min-occurs :init-keyword :min-occurs :init-value 1)
   (max-occurs :init-keyword :max-occurs :init-value 1)
   (parent     :init-keyword :parent :init-value #f)))

(define-class <complex-type> (<type>)
  ((contents :init-keyword :contents)
   (super    :init-keyword :super)))
(define-class <simple-type> (<type>) ())

(define-class <type&element> ()
  ((type :init-keyword :type)
   (element :init-keyword :element)))

;; for complex content just holds type
(define-class <base-type> ()
  ((type :init-keyword :type)
   (contents :init-keyword :contents)))

(define-method write-object ((o <type>) out)
  (format out "<~a ~a>" (class-name (class-of o)) (~ o 'name)))
(define-method write-object ((o <complex-type>) out)
  (format out "<complex-type ~a ~a>" (~ o 'name) (~ o 'contents)))

(define-method traverse ((e <xsd-compositor>)) 
  (let1 r (filter-map traverse (~ e 'children))
    r))

(define (generate-name e)
  (let ((this-name (schema-name e)))
    (when (and (null? (*parents*)) (not this-name))
      (error 'traverse "impossible to determine name" e))
    (or this-name ;; must be toplevel ComplexType (not checked though)
	(string-join (map schema-name (reverse (*parents*))) "."))))

(define (full-name e)
  (let ((namespace (~ e 'namespace))
	(name (schema-name e)))
    (if namespace
	(and name 
	     (string-append (~ e 'namespace) ":" name))
	name)))

;; TODO consider attributes
(define-method traverse (e) #f) ;; default

(define-method traverse ((e <xsd-extension>))
  ;; TODO should we handle missing type??
  (rlet1 r (make <base-type> :type (schema-base e))
    (set! (~ r 'contents)
	  (apply append (filter-map traverse (schema-children e))))))

(define-method traverse ((e <xsd-complex-content>))
  (let1 r (filter-map traverse (schema-children e))
    (apply append r)))

(define-method traverse ((e <xsd-simple-type>))
  (make <simple-type> :name (generate-name e) :full-name (full-name e)
	:element e :parent (and-let* (( (not (null? (*parents*))) ))
			     (car (*parents*)))))

(define-method traverse ((e <xsd-complex-type>))
  (define (get-min&max)
    (let1 parents (*parents*)
      (if (null? parents)
	  '()
	  (let1 e (car parents)
	    (list :min-occurs (schema-min-occurs e)
		  :max-occurs (schema-max-occurs e))))))
  ;; make sure all sequence/choice element will be flatten
  (define (flatten contents)
    (if (and (pair? contents) (pair? (car contents)))
	;; means the contents is sequence
	(let loop ((contents (car contents)) (r '()))
	  (cond ((null? contents) (reverse! r))
		((pair? (car contents))
		 (loop (cdr contents) `(,@(reverse! (car contents)) ,@r)))
		(else (loop (cdr contents) (cons (car contents) r)))))
	contents))
  (let ((contents (flatten (filter-map traverse (~ e 'children))))
	(name     (generate-name e))
	(full-name (full-name e)))
    (rlet1 r (apply make <complex-type> :name name 
		    :super (and (pair? contents) 
				(is-a? (car contents) <base-type>)
				(~ (car contents) 'type))
		    :contents (cond ((and (pair? contents)
					  (pair? (car contents)))
				     (car contents))
				    ((and (pair? contents) 
					  (is-a? (car contents) <base-type>))
				     (~ (car contents) 'contents))
				    (else contents))
		    :full-name full-name
		    :element e
		    :parent (and-let* (( (not (null? (*parents*))) ))
			      (car (*parents*)))
		    (get-min&max))
      ;; there is no way to extend annonymous type
      (when full-name (set! (~ type-table full-name) r)))))

(define-method traverse ((e <xml-schema-element>))
  (parameterize ((*parents* (cons e (*parents*))))
    (let1 contents (filter-map traverse (~ e 'children))
      (if (null? contents)
	  (or (and (~ e 'type) e) ;; toplevel element content must have type
	      (error 'traverse "element must have type" e))
	  ;; attributes are trimmed, so this should be ok
	  (make <type&element> :type (car contents) :element e)))))

(define (collect xsd)
  ;; for now
  ;; TODO xsd can be multiple such as xs:import.
  ;; make this capable to handle it.
  (let loop ((elements (~ (car xsd) 'elements))
	     (types '())
	     (stray-elements '()))
    (if (null? elements)
	(values types stray-elements)
	(let1 r (traverse (car elements))
	  (cond ((is-a? r <type>)
		 (loop (cdr elements) 
		       (cons r types) stray-elements))
		((is-a? r <type&element>)
		 ;; element with annonymous type
		 ;; we create element and type separately
		 ;; so need to be like this
		 ;; store it to both
		 (loop (cdr elements)
		       (cons r types)
		       (cons r stray-elements)))
		(else
		 ;; it's stray
		 (loop (cdr elements)
		       types (cons r stray-elements))))))))

;; we don't care this
(define-method generate-type-definition (type) #f)

;; FIXME, simple type must consider the namespace as well
(define-method generate-type-definition ((type <simple-type>))
  (let1 e (filter-map (lambda (child) 
			(and (is-a? child <xsd-restriction>)
			     child))
		      (~ type 'element 'children))
    (when  (or (null? e) (not (null? (cdr e))))
      (error 'generate-type-definition 
	     "simpleType only supports restrictions for now" e))
    (let1 simple-type (->scheme-type (~ (car e) 'base))
      `(define ,(string->symbol (->scheme-class-name (~ type 'name)))
	 ,simple-type))))

(define (%generate-content name e type min max)
  (let1 elm-name (string->symbol (schema-name e))
    `(,(string->symbol name)
      :init-keyword ,(->keyword name)
      ,@(if (eq? (string->symbol name) elm-name) '() `(:element-name ,elm-name))
      :element-type ,(list (->scheme-type type) min max))))

(define (split-name name) (car (last-pair (string-split name #/\./))))
;; for only debug
(define-method generate-content (e)
  (call-next-method))

(define-method generate-content ((e <xml-schema-element>))
  (let1 name (->scheme-name (schema-name e))
    (%generate-content name e (schema-type e)
		       (schema-min-occurs e) (schema-max-occurs e))))

;; nested annonymous types
(define-method generate-content ((e <complex-type>))
  ;; make slot name short...
  (%generate-content (split-name (~ e 'name))
		     (~ e 'parent) (~ e 'name)
		     (~ e 'min-occurs) (~ e 'max-occurs)))

(define-method generate-content ((e <simple-type>))
  ;; for now only restriction
  (let1 children (schema-children (~ e 'element))
    (unless (and (not (null? children)) (is-a? (car children) <xsd-restriction>))
      (error 'generate-content "simpleType only supprots restriction for now" e))
    (%generate-content (split-name (~ e 'name))
		       (~ e 'parent) (schema-base (car children))
		       (~ e 'min-occurs) (~ e 'max-occurs))))

(define-method generate-content ((e <type&element>))
  (generate-content (~ e 'type)))

(define-method generate-type-definition ((type <complex-type>))
  ;; TODO handle missing class??
  (define (get-super type)
    (cond ((~ type-table type)
	   => (lambda (t)
		(list (->scheme-type (~ t 'name)))))
	  (else '())))

  (define (generate-class type)
    (let ((contents (~ type 'contents))
	  (super (~ type 'super)))
      `(define-xml-type ,(string->symbol (->scheme-class-name (~ type 'name)))
	 ,(if super (get-super super) ())
	 ,(map generate-content contents)
	 :namespace ,(~ type 'element 'namespace))))
  (let1 contents (filter-map generate-type-definition (~ type 'contents))
    (if (null? contents)
	(generate-class type)
	`(begin 
	   ,@contents
	   ,(generate-class type)))))

(define-method generate-type-definition ((type <type&element>))
  (generate-type-definition (~ type 'type)))

(define-method generate-element-definition ((e <type&element>))
  (let ((e (~ e 'element))
	(type (~ e 'type)))
    `(define-xml-type ,(string->symbol (->scheme-class-name (schema-name e) #f))
       (,(->scheme-type (~ type 'name))) ()
       :element-type ,(->scheme-type (~ type 'name))
       :element-name ,(string->symbol (schema-name e))
       :namespace ,(schema-namespace e)))
  )
;; this is stray element which means the definition itself
;; doesn't have any children but only type specified in toplevel
;; simply create the type with element-name and so
(define-method generate-element-definition ((e <xml-schema-element>))
  `(define-xml-type ,(string->symbol (->scheme-class-name (schema-name e) #f))
     (,(->scheme-type (schema-type e))) ()
     :element-type ,(->scheme-type (schema-type e))
     :element-name ,(string->symbol (schema-name e))
     :namespace ,(schema-namespace e))
  )

;; TODO, seems not needed though...
(define (order types) types)

(define (read-from-string s) (read (open-string-input-port s)))
(define (main args)
  (with-args (cdr args)
      ((library-name (#\l "library") #t #f)
       (includes     (#\I "include") * '())
       (output       (#\o "output") #t #f)
       . rest)
    (when (null? rest) (usage))
    (unless (file-exists? (car rest))
      (format (current-error-port) "given file does not exist ~a" (car rest))
      (exit -1))
    (let1 xsd (parse-xsd-file (car rest) :locator (fixup-locator includes))
      (let-values (((types elements) (collect xsd)))
	(let ((type-defs (map generate-type-definition (order types)))
	      (element-defs (map generate-element-definition elements))
	      (out (or (and output (open-file-output-port output 
							  (file-options no-fail)
							  (buffer-mode block)
							  (native-transcoder)))
		       (current-output-port))))
	  (define (get-name def)
	    (and (not (eq? (car def) 'begin))
		 (cadr def)))
	  (define (get-nested-name def)
	    (and (eq? (car def) 'begin)
		 (map cadr (cdr def))))
	  (if library-name
	      (pp `(library ,(read-from-string library-name)
		       (export ,@(filter-map get-name type-defs)
			       ,@(apply append 
					(filter-map get-nested-name type-defs))
			       ,@(map cadr element-defs))
		       (import (rnrs) (text sxml xsd))
		     ,@type-defs
		     ,@element-defs)
		  out)
	      (begin
		(pp '(import (rnrs) (text sxml xsd)) out)
		(for-each (cut pp <> out) type-defs)
		(for-each (cut pp <> out) element-defs))))))))
